<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.4.4/randomColor.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r82/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Paremters to be adjusted for differnt behaviors, these were chosen by trial and error
        var coh = 6.5;
        var sep = 7;
        var ali = 6.5;
        var amount = 500;
        var spread = 80;
        var speed = 35;
        var view = 7;

        // Create a scene which will hold all our meshes to be rendered
        var scene = new THREE.Scene();

        // A list that all bird objects will be held in
        var birds = [];


        // Create and position a camera
        var camera = new THREE.PerspectiveCamera(
            60, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping pane
            1000 // Far clipping pane
        );

        // Reposition the camera
        camera.position.set(0, 30, 50);

        // Point the camera at a given coordinate
        camera.lookAt(new THREE.Vector3(0, 15, 0))

        // Create a renderer
        var renderer = new THREE.WebGLRenderer({
            antialias: true
        });

        // Size should be the same as the window
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Set a near white clear color (default is black)
        renderer.setClearColor(0xfff6e6);

        // Enable shadow mapping
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Append to the document
        document.body.appendChild(renderer.domElement);

        // Add an ambient lights
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.5);
        scene.add(light);

        // Add a point light that will cast shadows
        var pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(25, 50, 25);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 1024;
        pointLight.shadow.mapSize.height = 1024;
        scene.add(pointLight);

        // A basic material that will be the ground
        var shadowMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            shading: THREE.FlatShading,
            metalness: 0,
            roughness: 0.8
        });
        shadowMaterial.opacity = 0.5;
        let groundSize = 10000;
        var groundMesh = new THREE.Mesh(
            new THREE.BoxGeometry(groundSize, .1, groundSize),
            shadowMaterial
        );
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);


        for (var i = 0; i < amount; i++) {
            birds.push(new Bird());
            scene.add(birds[i].shape);
            birds[i].id = i;
        }



        // Add an orbit control which allows moving around the scene. See the three.js example for more details
        // https://github.com/mrdoob/three.js/blob/dev/examples/js/controls/OrbitControls.
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target = new THREE.Vector3(0, 15, 0);
        controls.maxPolarAngle = Math.PI / 2;
        requestAnimationFrame(render);

        function render() {
            for (bird of birds) {
                // steering behavoir sets velocity
                bird.steer(birds);
                // update moves the boids location based on velocity
                bird.update(1 / 60);
            }
            // Update camera position based on the controls
            controls.update();

            // Re-render the scene
            renderer.render(scene, camera);

            // Loop
            requestAnimationFrame(render);
        }



        function Bird() {
            // creates the cone shape of a random colour
            this.shape = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 6), new THREE.MeshStandardMaterial({
                color: parseInt(randomColor().substring(1), 16),
                shading: THREE.FlatShading,
                metalness: 0,
                roughness: 0.8
            }));
            // sets its location
            this.shape.position.y += spread * (2 * Math.random());
            this.shape.position.z += spread * (2 * Math.random() - 1);
            this.shape.position.x += spread * (2 * Math.random() - 1);

            this.shape.castShadow = true;

            this.velocity = new THREE.Vector3(2 * Math.random() - 1, Math.random(), 2 * Math.random() - 1);
            this.velocity.normalize();
            
            // id is for debugging purposes
            this.id = 1;

            this.steer = function(birds) {
                let pos = this.shape.position.clone();

                let numInTheHood = 0;

                let alignment = new THREE.Vector3();
                let cohesion = new THREE.Vector3();
                let separation = new THREE.Vector3();

                let self = this;
                for (b of birds) {
                    let bpos = b.shape.position.clone();
                    let bvel = b.velocity.clone();
                    if (self !== b) {
                        // Does not check self
                        if (bpos.distanceToSquared(pos) < Math.pow(view, 2)) {
                            // If this bird is on the neighbourhood
                            
                            // adds all velocity of boids in vicinity
                            alignment.add(bvel);
                            
                             // adds all positions of boids in vicinity
                            cohesion.add(bpos);
                            
                            // calculates a scaling seperation force that increases nonlinearly when other boids get closer
                            separation.add(bpos).sub(pos).multiplyScalar(5 / bpos.distanceTo(pos));
                            
                            // counts the number of boids in vicinity for later calulations
                            numInTheHood++;
                        }
                    }
                }
                // adds a repulstion force from the ground
                let floor = new THREE.Vector3();
                if (pos.y < 5) {
                    floor.y = Math.abs(5 / pos.y);
                }
                
                // uses the total velocity to calculate the average velocity of those in the vicinity
                alignment.divideScalar(numInTheHood);
                alignment.normalize();
                alignment.multiplyScalar(ali);

                //uses the total positions to calculate center of mass, then calculates the vector from its current location to the center of mass
                cohesion.divideScalar(numInTheHood);
                cohesion.sub(pos);
                cohesion.normalize();
                cohesion.multiplyScalar(coh);

                //uses all total seperations to repel itself from others
                separation.divideScalar(-numInTheHood);
                separation.normalize();
                separation.multiplyScalar(sep);

                // takes into account all steerings, and adds it to the current velocity, then scales it to speed
                this.velocity.add(cohesion).add(alignment).add(separation).add(floor).normalize().multiplyScalar(speed);
            }

            this.update = function(delta) {
                // sets new position from velocity
                this.shape.position.addScaledVector(this.velocity, delta);
                if (this.velocity.length() != 0) {
                    // If the velocity is not zero, sets the rotation of the shape to align with direction
                    this.shape.rotation.setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), this.velocity.clone().normalize()));
                }
            }
        }
    </script>
</body>

</html>
